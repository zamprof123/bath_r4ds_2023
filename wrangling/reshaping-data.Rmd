---
title: "Reshaping Data"
author: "Rafael A. Irizarry"
date: "`r lubridate::today()`"
output:
  ioslides_presentation:
    fig_caption: no
    fig_height: 5
    fig_width: 7
    out_width: "70%"
  beamer_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
library(tidyverse)
library(dslabs)
library(gridExtra)
library(ggthemes)
ds_theme_set()
options(digits = 3)
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "70%",
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

img_path <- "img"
```

## Reshaping data

- As we have seen through the book, having data in _tidy_ format is what makes the tidyverse flow.

- After the first step in the data analysis process, importing data, a common next step is to reshape the data into a form that facilitates the rest of the analysis.

- The __tidyr__ package includes several functions that are useful for tidying data.

- We will use the fertility wide format dataset previously described.



## Reshaping data

```{r, message=FALSE, warning=FALSE} 
library(tidyverse)  
library(dslabs) 
path <- system.file("extdata", package="dslabs") 
filename <- file.path(path, "fertility-two-countries-example.csv") 
wide_data <- read_csv(filename) 
``` 


## `pivot_longer`

- One of the most used functions in the __tidyr__ package is `pivot_longer`, which is useful for converting wide data into tidy data.

- As with most tidyverse functions, the `pivot_longer` function's first argument is the data frame that will be converted.

- Here we want to reshape the `wide_data` dataset so that each row represents a fertility observation, which implies we need three columns to store the year, country, and the observed value.

- In its current form, data from different years are in different columns with the year values stored in the column names.



## `pivot_longer`

- Through the `names_to` and `values_to` argument we will tell `pivot_longer` the column names we want to assign to the columns containing the current column names and observations, respectively.

- The default names are `name` and `value`, which are often usable choices.

- In this case a better choice for these two arguments would be `year` and `fertility`.

- Note that nowhere in the data file does it tell us this is fertility data.

- Instead, we deciphered this from the file name.



## `pivot_longer`

- Through `cols`,the second argument we specify the columns containing observed values; these are the columns that will be _pivoted_.

- The default is to pivot all columns so, in most cases, we have to specify the columns.

- In our example we want columns `1960`, `1961` up to `2015`.

## `pivot_longer`

- The code to pivot the fertility data therefore looks like this:

```{r} 
new_tidy_data <- pivot_longer(wide_data, `1960`:`2015`,
                              names_to = "year", 
                              values_to = "fertility") 
``` 

## `pivot_longer`

- We can also use the pipe like this:

```{r} 
new_tidy_data <- wide_data |>  
  pivot_longer(`1960`:`2015`, 
               names_to = "year", values_to = "fertility") 
``` 


## `pivot_longer`

- We can see that the data have been converted to tidy format with columns `year` and `fertility`:

```{r} 
head(new_tidy_data) 
``` 


## `pivot_longer`

- and that each year resulted in two rows since we have two countries and this column was not pivoted.

- A somewhat quicker way to write this code is to specify which column will **not** include in the pivot, rather than all the columns that will be pivoted:

```{r} 
new_tidy_data <- wide_data |> 
  pivot_longer(-country, names_to = "year", values_to = "fertility") 
``` 


## `pivot_longer`

- The `new_tidy_data` object looks like the original `tidy_data` we defined this way:


```{r} 
data("gapminder") 
tidy_data <- gapminder |>  
  filter(country %in% c("South Korea", "Germany") & 
           !is.na(fertility)) |> 
  select(country, year, fertility) 
``` 

## `pivot_longer`

- There is just one minor difference. Can you spot it? Look at the data type of the year column:

```{r} 
class(tidy_data$year) 
class(new_tidy_data$year) 
``` 

- The `pivot_longer` function assumes that column names are characters.

- So we need a bit more wrangling before we are ready to make a plot.


## `pivot_longer`

- We need to convert the year column to be numbers:

```{r} 
new_tidy_data <- wide_data |> 
  pivot_longer(-country, 
               names_to = "year", 
               values_to = "fertility") |> 
  mutate(year = as.integer(year)) 
``` 

- Note that we could have also used the `mutate` and `as.numeric`.




## `pivot_longer`

- Now that the data is tidy, we can use this relatively simple ggplot code:

```{r fertility-year-check, eval=FALSE} 
new_tidy_data |> 
  ggplot(aes(year, fertility, color = country)) +  
  geom_point() 
``` 


## `pivot_wider`

- As we will see in later examples, it is sometimes useful for data wrangling purposes to convert tidy data into wide data.

- We often use this as an intermediate step in tidying up data.

- The `pivot_wider` function is basically the inverse of `pivot_longer`.

- The first argument is for the data, but since we are using the pipe, we don't show it.

- The `names_from` argument tells `pivot_wider` which variable will be used as the column names.

- The `values_from` argument specifies which variable to use to fill out the cells.



## `pivot_wider`

```{r} 
new_wide_data <- new_tidy_data |>  
  pivot_wider(names_from = year,
              values_from = fertility) 
select(new_wide_data, country, `1960`:`1966`) 
``` 

- Similar to `pivot_wider`, `names_from` and `values_from` default to `name` and `value`.

## `pivot_wider`

- The following diagram can help remind you how these two functions work:

```{r, echo=FALSE} 
knitr::include_graphics(file.path(img_path,"gather-spread.png")) 
``` 



## `separate`

- The data wrangling shown above was simple compared to what is usually required.

- In our example spreadsheet files, we include an illustration that is slightly more complicated.

- It contains two variables: life expectancy and fertility.

## `separate`

- However, the way it is stored is not tidy and, as we will explain, not optimal.

```{r, message=FALSE} 
path <- system.file("extdata", package = "dslabs") 
filename <- "life-expectancy-and-fertility-two-countries-example.csv" 
filename <-  file.path(path, filename) 
raw_dat <- read_csv(filename) 
select(raw_dat, 1:4) 
``` 




## `separate`

- First, note that the data is in wide format.

- Second, notice that this table includes values for two variables, fertility and life expectancy, with the column name encoding which column represents which variable.

- Encoding information in the column names is not recommended but, unfortunately, it is quite common.

- We will put our wrangling skills to work to extract this information and store it in a tidy fashion.

- We can start the data wrangling with the `pivot_longer` function, but we should no longer use the column name `year` for the new column since it also contains the variable type.




## `separate`

- We will call it `name`, the default, for now:

```{r} 
dat <- raw_dat |> pivot_longer(-country) 
head(dat) 
``` 

## `separate`

- The result is not exactly what we refer to as tidy since each observation is associated with two, not one, rows.

- We want to have the values from the two variables, fertility and life expectancy, in two separate columns.

- The first challenge to achieve this is to separate the `name` column into the year and the variable type.

## `separate`

- Notice that the entries in this column separate the year from the variable name with an underscore:

```{r} 
dat$name[1:5] 
``` 


## `separate`

- Encoding multiple variables in a column name is such a common problem that the __readr__ package includes a function to separate these columns into two or more.

- Apart from the data, the `separate` function takes three arguments: the name of the column to be separated, the names to be used for the new columns, and the character that separates the variables.

- So, a first attempt at this is:

```{r, eval=FALSE} 
dat |> separate(name, c("year", "name"), "_") 
``` 

## `separate`

- Because `_` is the default separator assumed by `separate`, we do not have to include it in the code:

```{r} 
dat |> separate(name, c("year", "name")) 
``` 


## `separate`

- The function does separate the values, but we run into a new problem.

- We receive the warning `Too many values at 112 locations:` and that the `life_expectancy` variable is truncated to `life`.

- This is because the `_` is used to separate `life` and `expectancy`, not just year and variable name! We could add a third column to catch this and let the `separate` function know which column to _fill in_ with missing values, `NA`, when there is no third value.

## `separate`

- Here we tell it to fill the column on the right:

```{r} 
var_names <- c("year", "first_variable_name", "second_variable_name") 
dat |> separate(name, var_names, fill = "right") 
``` 


## `separate`

- However, if we read the `separate` help file, we find that a better approach is to merge the last two variables when there is an extra separation:

```{r} 
dat |> separate(name, c("year", "name"), extra = "merge") 
``` 
- This achieves the separation we wanted.

- However, we are not done yet.

- We need to create a column for each variable.

## `separate`

- As we learned, the `pivot_wider` function can do this:

```{r} 
dat |>  
  separate(name, c("year", "name"), extra = "merge") |> 
  pivot_wider() 
``` 


## `separate`

- The data is now in tidy format with one row for each observation with three variables: year, fertility, and life expectancy.



## `unite`

- It is sometimes useful to do the inverse of `separate`, unite two columns into one.

- To demonstrate how to use `unite`, we show code that, although *not* the optimal approach, serves as an illustration.

## `unite`

- Suppose that we did not know about `extra` and used this command to separate:

```{r} 
var_names <- c("year", "first_variable_name", "second_variable_name") 
dat |>  
  separate(name, var_names, fill = "right") 
``` 

- We can achieve the same final result by uniting the second and third columns, then pivoting the columns and renaming `fertility_NA` to `fertility`:



## `unite`

```{r} 
dat |>  
  separate(name, var_names, fill = "right") |> 
  unite(name, first_variable_name, second_variable_name) |> 
  pivot_wider() |> 
  rename(fertility = fertility_NA) 
``` 
